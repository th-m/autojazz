'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Writer = exports.VexFlow = exports.Utils = exports.Track = exports.ProgramChangeEvent = exports.NoteOnEvent = exports.NoteOffEvent = exports.NoteEvent = exports.MetaEvent = exports.Constants = exports.Chunk = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _tonalMidi = require('tonal-midi');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Object representation of the chunk section of a MIDI file.
 * @param {object} fields - {type: number, data: array, size: array}
 * @return {Chunk}
 */
var Chunk = function Chunk(fields) {
	_classCallCheck(this, Chunk);

	this.type = fields.type;
	this.data = fields.data;
	this.size = [0, 0, 0, fields.data.length];
};

exports.Chunk = Chunk;
/**
 * MIDI file format constants, including note -> MIDI number translation.
 * @return {Constants}
 */

var Constants = {
	VERSION: '1.5.1',
	HEADER_CHUNK_TYPE: [0x4d, 0x54, 0x68, 0x64], // Mthd
	HEADER_CHUNK_LENGTH: [0x00, 0x00, 0x00, 0x06], // Header size for SMF
	HEADER_CHUNK_FORMAT0: [0x00, 0x00], // Midi Type 0 id
	HEADER_CHUNK_FORMAT1: [0x00, 0x01], // Midi Type 1 id
	HEADER_CHUNK_DIVISION: [0x00, 0x80], // Defaults to 128 ticks per beat
	TRACK_CHUNK_TYPE: [0x4d, 0x54, 0x72, 0x6b], // MTrk,
	META_EVENT_ID: 0xFF,
	META_TEXT_ID: 0x01,
	META_COPYRIGHT_ID: 0x02,
	META_TRACK_NAME_ID: 0x03,
	META_INSTRUMENT_NAME_ID: 0x04,
	META_LYRIC_ID: 0x05,
	META_MARKER_ID: 0x06,
	META_CUE_POINT: 0x07,
	META_TEMPO_ID: 0x51,
	META_SMTPE_OFFSET: 0x54,
	META_TIME_SIGNATURE_ID: 0x58,
	META_KEY_SIGNATURE_ID: 0x59,
	META_END_OF_TRACK_ID: [0x2F, 0x00],
	PROGRAM_CHANGE_STATUS: 0xC0 // includes channel number (0)
};

exports.Constants = Constants;
/**
 * Object representation of a meta event.
 * @param {object} fields - type, data
 * @return {MetaEvent}
 */

var MetaEvent = function MetaEvent(fields) {
	_classCallCheck(this, MetaEvent);

	this.type = 'meta';
	this.data = Utils.numberToVariableLength(0x00); // Start with zero time delta
	this.data = this.data.concat(Constants.META_EVENT_ID, fields.data);
};

exports.MetaEvent = MetaEvent;
/**
 * Wrapper for noteOnEvent/noteOffEvent objects that builds both events.
 * @param {object} fields - {pitch: '[C4]', duration: '4', wait: '4', velocity: 1-100}
 * @return {NoteEvent}
 */

var NoteEvent = function () {
	function NoteEvent(fields) {
		_classCallCheck(this, NoteEvent);

		this.type = 'note';
		this.pitch = Utils.toArray(fields.pitch);
		this.wait = fields.wait || 0;
		this.duration = fields.duration;
		this.sequential = fields.sequential || false;
		this.velocity = fields.velocity || 50;
		this.channel = fields.channel || 1;
		this.repeat = fields.repeat || 1;
		this.velocity = this.convertVelocity(this.velocity);
		this.grace = fields.grace;
		this.buildData();
	}

	/**
  * Builds int array for this event.
  * @return {NoteEvent}
  */


	_createClass(NoteEvent, [{
		key: 'buildData',
		value: function buildData() {
			this.data = [];

			var tickDuration = this.getTickDuration(this.duration, 'note');
			var restDuration = this.getTickDuration(this.wait, 'rest');

			// Apply grace note(s) and subtract ticks (currently 1 tick per grace note) from tickDuration so net value is the same
			if (this.grace) {
				var graceDuration = 1;
				this.grace = Utils.toArray(this.grace);
				this.grace.forEach(function (pitch) {
					var noteEvent = new NoteEvent({ pitch: this.grace, duration: 'T' + graceDuration });
					this.data = this.data.concat(noteEvent.data);

					tickDuration -= graceDuration;
				}, this);
			}

			// fields.pitch could be an array of pitches.
			// If so create note events for each and apply the same duration.
			var noteOn, noteOff;
			if (Array.isArray(this.pitch)) {
				// By default this is a chord if it's an array of notes that requires one NoteOnEvent.
				// If this.sequential === true then it's a sequential string of notes that requires separate NoteOnEvents.
				if (!this.sequential) {
					// Handle repeat
					for (var j = 0; j < this.repeat; j++) {
						// Note on
						this.pitch.forEach(function (p, i) {
							if (i == 0) {
								noteOn = new NoteOnEvent({ data: Utils.numberToVariableLength(restDuration).concat(this.getNoteOnStatus(), Utils.getPitch(p), this.velocity) });
							} else {
								// Running status (can ommit the note on status)
								noteOn = new NoteOnEvent({ data: [0, Utils.getPitch(p), this.velocity] });
							}

							this.data = this.data.concat(noteOn.data);
						}, this);

						// Note off
						this.pitch.forEach(function (p, i) {
							if (i == 0) {
								noteOff = new NoteOffEvent({ data: Utils.numberToVariableLength(tickDuration).concat(this.getNoteOffStatus(), Utils.getPitch(p), this.velocity) });
							} else {
								// Running status (can ommit the note off status)
								noteOff = new NoteOffEvent({ data: [0, Utils.getPitch(p), this.velocity] });
							}

							this.data = this.data.concat(noteOff.data);
						}, this);
					}
				} else {
					// Handle repeat
					for (var j = 0; j < this.repeat; j++) {
						this.pitch.forEach(function (p, i) {
							// restDuration only applies to first note
							if (i > 0) {
								restDuration = 0;
							}

							// If duration is 8th triplets we need to make sure that the total ticks == quarter note.
							// So, the last one will need to be the remainder
							if (this.duration === '8t' && i == this.pitch.length - 1) {
								var quarterTicks = Utils.numberFromBytes(Constants.HEADER_CHUNK_DIVISION);
								tickDuration = quarterTicks - tickDuration * 2;
							}

							noteOn = new NoteOnEvent({ data: Utils.numberToVariableLength(restDuration).concat([this.getNoteOnStatus(), Utils.getPitch(p), this.velocity]) });
							noteOff = new NoteOffEvent({ data: Utils.numberToVariableLength(tickDuration).concat([this.getNoteOffStatus(), Utils.getPitch(p), this.velocity]) });

							this.data = this.data.concat(noteOn.data, noteOff.data);
						}, this);
					}
				}

				return this;
			}

			throw 'pitch must be an array.';
		}
	}, {
		key: 'convertVelocity',


		/**
   * Converts velocity to value 0-127
   * @param {number} velocity - Velocity value 1-100
   * @return {number}
   */
		value: function convertVelocity(velocity) {
			// Max passed value limited to 100
			velocity = velocity > 100 ? 100 : velocity;
			return Math.round(velocity / 100 * 127);
		}
	}, {
		key: 'getTickDuration',


		/**
   * Gets the total number of ticks based on passed duration.
   * Note: type=='note' defaults to quarter note, type==='rest' defaults to 0
   * @param {(string|array)} duration
   * @param {string} type ['note', 'rest']
   * @return {number}
   */
		value: function getTickDuration(duration, type) {
			if (Array.isArray(duration)) {
				// Recursively execute this method for each item in the array and return the sum of tick durations.
				return duration.map(function (value) {
					return this.getTickDuration(value, type);
				}, this).reduce(function (a, b) {
					return a + b;
				}, 0);
			}

			duration = duration.toString();

			if (duration.toLowerCase().charAt(0) === 't') {
				// If duration starts with 't' then the number that follows is an explicit tick count
				return parseInt(duration.substring(1));
			}

			// Need to apply duration here.  Quarter note == Constants.HEADER_CHUNK_DIVISION
			// Rounding only applies to triplets, which the remainder is handled below
			var quarterTicks = Utils.numberFromBytes(Constants.HEADER_CHUNK_DIVISION);
			return Math.round(quarterTicks * this.getDurationMultiplier(duration, type));
		}

		/**
   * Gets what to multiple ticks/quarter note by to get the specified duration.
   * Note: type=='note' defaults to quarter note, type==='rest' defaults to 0
   * @param {string} duration
   * @param {string} type ['note','rest']
   * @return {number}
   */

	}, {
		key: 'getDurationMultiplier',
		value: function getDurationMultiplier(duration, type) {
			// Need to apply duration here.  Quarter note == Constants.HEADER_CHUNK_DIVISION
			switch (duration) {
				case '0':
					return 0;
				case '1':
					return 4;
				case '2':
					return 2;
				case 'd2':
					return 3;
				case '4':
					return 1;
				case '4t':
					return 0.666;
				case 'd4':
					return 1.5;
				case '8':
					return 0.5;
				case '8t':
					// For 8th triplets, let's divide a quarter by 3, round to the nearest int, and substract the remainder to the last one.
					return 0.33;
				case 'd8':
					return 0.75;
				case '16':
					return 0.25;
				case '16t':
					return 0.166;
				case '32':
					return 0.125;
				case '64':
					return 0.0625;
				default:
				// Notes default to a quarter, rests default to 0
				//return type === 'note' ? 1 : 0;
			}

			throw duration + ' is not a valid duration.';
		}
	}, {
		key: 'getNoteOnStatus',


		/**
   * Gets the note on status code based on the selected channel. 0x9{0-F}
   * Note on at channel 0 is 0x90 (144)
   * 0 = Ch 1
   * @return {number}
   */
		value: function getNoteOnStatus() {
			return 144 + this.channel - 1;
		}

		/**
   * Gets the note off status code based on the selected channel. 0x8{0-F}
   * Note off at channel 0 is 0x80 (128)
   * 0 = Ch 1
   * @return {number}
   */

	}, {
		key: 'getNoteOffStatus',
		value: function getNoteOffStatus() {
			return 128 + this.channel - 1;
		}
	}]);

	return NoteEvent;
}();

exports.NoteEvent = NoteEvent;
/**
 * Holds all data for a "note off" MIDI event
 * @param {object} fields {data: []}
 * @return {NoteOffEvent}
 */

var NoteOffEvent = function NoteOffEvent(fields) {
	_classCallCheck(this, NoteOffEvent);

	this.data = fields.data;
};

exports.NoteOffEvent = NoteOffEvent;
/**
 * Holds all data for a "note on" MIDI event
 * @param {object} fields {data: []}
 * @return {NoteOnEvent}
 */

var NoteOnEvent = function NoteOnEvent(fields) {
	_classCallCheck(this, NoteOnEvent);

	this.data = fields.data;
};

exports.NoteOnEvent = NoteOnEvent;
/**
 * Holds all data for a "program change" MIDI event
 * @param {object} fields {type: string, data: []}
 * @return {NoteOffEvent}
 */

var ProgramChangeEvent = function ProgramChangeEvent(fields) {
	_classCallCheck(this, ProgramChangeEvent);

	this.type = 'program';
	// delta time defaults to 0.
	this.data = Utils.numberToVariableLength(0x00).concat(Constants.PROGRAM_CHANGE_STATUS, fields.instrument);
};

exports.ProgramChangeEvent = ProgramChangeEvent;
/**
 * Holds all data for a track.
 * @param {object} fields {type: number, data: array, size: array, events: array}
 * @return {Track}
 */

var Track = function () {
	function Track() {
		_classCallCheck(this, Track);

		this.type = Constants.TRACK_CHUNK_TYPE;
		this.data = [];
		this.size = [];
		this.events = [];
	}

	/**
  * Adds any event type to the track.
  * @param {(NoteEvent|MetaEvent|ProgramChangeEvent)} event - Event object.
  * @param {function} mapFunction - Callback which can be used to apply specific properties to all events. 
  * @return {Track}
  */


	_createClass(Track, [{
		key: 'addEvent',
		value: function addEvent(event, mapFunction) {
			if (Array.isArray(event)) {
				event.forEach(function (e, i) {
					// Handle map function if provided
					if (typeof mapFunction === 'function' && e.type === 'note') {
						var properties = mapFunction(i, e);

						if ((typeof properties === 'undefined' ? 'undefined' : _typeof(properties)) === 'object') {
							for (var j in properties) {
								switch (j) {
									case 'duration':
										e.duration = properties[j];
										break;
									case 'sequential':
										e.sequential = properties[j];
										break;
									case 'velocity':
										e.velocity = e.convertVelocity(properties[j]);
										break;
								}
							}

							// Gotta build that data
							e.buildData();
						}
					}

					this.data = this.data.concat(e.data);
					this.size = Utils.numberToBytes(this.data.length, 4); // 4 bytes long
					this.events.push(e);
				}, this);
			} else {
				this.data = this.data.concat(event.data);
				this.size = Utils.numberToBytes(this.data.length, 4); // 4 bytes long
				this.events.push(event);
			}

			return this;
		}

		/**
   * Sets tempo of the MIDI file.
   * @param {number} bpm - Tempo in beats per minute.
   * @return {Track}
   */

	}, {
		key: 'setTempo',
		value: function setTempo(bpm) {
			var event = new MetaEvent({ data: [Constants.META_TEMPO_ID] });
			event.data.push(0x03); // Size
			var tempo = Math.round(60000000 / bpm);
			event.data = event.data.concat(Utils.numberToBytes(tempo, 3)); // Tempo, 3 bytes
			return this.addEvent(event);
		}

		/**
   * Sets time signature.
   * @param {number} numerator - Top number of the time signature.
   * @param {number} denominator - Bottom number of the time signature.
   * @param {number} midiclockspertick - Defaults to 24.
   * @param {number} notespermidiclock - Defaults to 8.
   * @return {Track}
   */

	}, {
		key: 'setTimeSignature',
		value: function setTimeSignature(numerator, denominator, midiclockspertick, notespermidiclock) {
			midiclockspertick = midiclockspertick || 24;
			notespermidiclock = notespermidiclock || 8;

			var event = new MetaEvent({ data: [Constants.META_TIME_SIGNATURE_ID] });
			event.data.push(0x04); // Size
			event.data = event.data.concat(Utils.numberToBytes(numerator, 1)); // Numerator, 1 bytes

			var _denominator = Math.log2(denominator); // Denominator is expressed as pow of 2
			event.data = event.data.concat(Utils.numberToBytes(_denominator, 1)); // Denominator, 1 bytes
			event.data = event.data.concat(Utils.numberToBytes(midiclockspertick, 1)); // MIDI Clocks per tick, 1 bytes
			event.data = event.data.concat(Utils.numberToBytes(notespermidiclock, 1)); // Number of 1/32 notes per MIDI clocks, 1 bytes
			return this.addEvent(event);
		}

		/**
   * Sets key signature.
   * @param {*} sf - 
   * @param {*} mi -
   * @return {Track}
   */

	}, {
		key: 'setKeySignature',
		value: function setKeySignature(sf, mi) {
			var event = new MetaEvent({ data: [Constants.META_KEY_SIGNATURE_ID] });
			event.data.push(0x02); // Size

			var mode = mi || 0;
			sf = sf || 0;

			//	Function called with string notation
			if (typeof mi === 'undefined') {
				var fifths = [['Cb', 'Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#'], ['ab', 'eb', 'bb', 'f', 'c', 'g', 'd', 'a', 'e', 'b', 'f#', 'c#', 'g#', 'd#', 'a#']];
				var _sflen = sf.length;
				var note = sf || 'C';

				if (sf[0] === sf[0].toLowerCase()) mode = 1;

				if (_sflen > 1) {
					switch (sf.charAt(_sflen - 1)) {
						case 'm':
							mode = 1;
							note = sf.charAt(0).toLowerCase();
							note = note.concat(sf.substring(1, _sflen - 1));
							break;
						case '-':
							mode = 1;
							note = sf.charAt(0).toLowerCase();
							note = note.concat(sf.substring(1, _sflen - 1));
							break;
						case 'M':
							mode = 0;
							note = sf.charAt(0).toUpperCase();
							note = note.concat(sf.substring(1, _sflen - 1));
							break;
						case '+':
							mode = 0;
							note = sf.charAt(0).toUpperCase();
							note = note.concat(sf.substring(1, _sflen - 1));
							break;
					}
				}

				var fifthindex = fifths[mode].indexOf(note);
				sf = fifthindex === -1 ? 0 : fifthindex - 7;
			}

			event.data = event.data.concat(Utils.numberToBytes(sf, 1)); // Number of sharp or flats ( < 0 flat; > 0 sharp)
			event.data = event.data.concat(Utils.numberToBytes(mode, 1)); // Mode: 0 major, 1 minor
			return this.addEvent(event);
		}

		/**
   * Adds text to MIDI file.
   * @param {string} text - Text to add.
   * @return {Track}
   */

	}, {
		key: 'addText',
		value: function addText(text) {
			var event = new MetaEvent({ data: [Constants.META_TEXT_ID] });
			var stringBytes = Utils.stringToBytes(text);
			event.data = event.data.concat(Utils.numberToVariableLength(stringBytes.length)); // Size
			event.data = event.data.concat(stringBytes); // Text
			return this.addEvent(event);
		}

		/**
   * Adds copyright to MIDI file.
   * @param {string} text - Text of copyright line.
   * @return {Track}
   */

	}, {
		key: 'addCopyright',
		value: function addCopyright(text) {
			var event = new MetaEvent({ data: [Constants.META_COPYRIGHT_ID] });
			var stringBytes = Utils.stringToBytes(text);
			event.data = event.data.concat(Utils.numberToVariableLength(stringBytes.length)); // Size
			event.data = event.data.concat(stringBytes); // Text
			return this.addEvent(event);
		}

		/**
   * Adds Sequence/Track Name.
   * @param {string} text - Text of track name.
   * @return {Track}
   */

	}, {
		key: 'addTrackName',
		value: function addTrackName(text) {
			var event = new MetaEvent({ data: [Constants.META_TRACK_NAME_ID] });
			var stringBytes = Utils.stringToBytes(text);
			event.data = event.data.concat(Utils.numberToVariableLength(stringBytes.length)); // Size
			event.data = event.data.concat(stringBytes); // Text
			return this.addEvent(event);
		}

		/**
   * Sets instrument name of track.
   * @param {string} text - Name of instrument.
   * @return {Track}
   */

	}, {
		key: 'addInstrumentName',
		value: function addInstrumentName(text) {
			var event = new MetaEvent({ data: [Constants.META_INSTRUMENT_NAME_ID] });
			var stringBytes = Utils.stringToBytes(text);
			event.data = event.data.concat(Utils.numberToVariableLength(stringBytes.length)); // Size
			event.data = event.data.concat(stringBytes); // Text
			return this.addEvent(event);
		}

		/**
   * Adds marker to MIDI file.
   * @param {string} text - Marker text.
   * @return {Track}
   */

	}, {
		key: 'addMarker',
		value: function addMarker(text) {
			var event = new MetaEvent({ data: [Constants.META_MARKER_ID] });
			var stringBytes = Utils.stringToBytes(text);
			event.data = event.data.concat(Utils.numberToVariableLength(stringBytes.length)); // Size
			event.data = event.data.concat(stringBytes); // Text
			return this.addEvent(event);
		}

		/**
   * Adds cue point to MIDI file.
   * @param {string} text - Text of cue point.
   * @return {Track}
   */

	}, {
		key: 'addCuePoint',
		value: function addCuePoint(text) {
			var event = new MetaEvent({ data: [Constants.META_CUE_POINT] });
			var stringBytes = Utils.stringToBytes(text);
			event.data = event.data.concat(Utils.numberToVariableLength(stringBytes.length)); // Size
			event.data = event.data.concat(stringBytes); // Text
			return this.addEvent(event);
		}

		/**
   * Adds lyric to MIDI file.
   * @param {string} lyric - Lyric text to add.
   * @return {Track}
   */

	}, {
		key: 'addLyric',
		value: function addLyric(lyric) {
			var event = new MetaEvent({ data: [Constants.META_LYRIC_ID] });
			var stringBytes = Utils.stringToBytes(lyric);
			event.data = event.data.concat(Utils.numberToVariableLength(stringBytes.length)); // Size
			event.data = event.data.concat(stringBytes); // Lyric
			return this.addEvent(event);
		}

		/**
   * Channel mode messages
   * @return {Track}
   */

	}, {
		key: 'polyModeOn',
		value: function polyModeOn() {
			var event = new NoteOnEvent({ data: [0x00, 0xB0, 0x7E, 0x00] });
			return this.addEvent(event);
		}
	}]);

	return Track;
}();

exports.Track = Track;

/**
 * Static utility functions used throughout the library.
 */
var Utils = function () {
	function Utils() {
		_classCallCheck(this, Utils);
	}

	_createClass(Utils, null, [{
		key: 'version',


		/**
   * Gets MidiWriterJS version number.
   * @return {string}
   */
		value: function version() {
			return Constants.VERSION;
		}

		/**
   * Convert a string to an array of bytes
   * @param {string} string
   * @return {array}
   */

	}, {
		key: 'stringToBytes',
		value: function stringToBytes(string) {
			return string.split('').map(function (char) {
				return char.charCodeAt();
			});
		}

		/**
   * Checks if argument is a valid number.
   * @param {*} n - Value to check
   * @return {boolean}
   */

	}, {
		key: 'isNumeric',
		value: function isNumeric(n) {
			return !isNaN(parseFloat(n)) && isFinite(n);
		}

		/**
      * Returns the correct MIDI number for the specified pitch.
      * Uses Tonal Midi - https://github.com/danigb/tonal/tree/master/packages/midi
      * @param {(string|number)} pitch - 'C#4' or midi note code
      * @return {number}
      */

	}, {
		key: 'getPitch',
		value: function getPitch(pitch) {
			return (0, _tonalMidi.toMidi)(pitch);
		}

		/**
   * Translates number of ticks to MIDI timestamp format, returning an array of
   * hex strings with the time values. Midi has a very particular time to express time,
   * take a good look at the spec before ever touching this function.
   * Thanks to https://github.com/sergi/jsmidi
   *
   * @param {number} ticks - Number of ticks to be translated
   * @return {array} - Bytes that form the MIDI time value
   */

	}, {
		key: 'numberToVariableLength',
		value: function numberToVariableLength(ticks) {
			var buffer = ticks & 0x7F;

			while (ticks = ticks >> 7) {
				buffer <<= 8;
				buffer |= ticks & 0x7F | 0x80;
			}

			var bList = [];
			while (true) {
				bList.push(buffer & 0xff);

				if (buffer & 0x80) buffer >>= 8;else {
					break;
				}
			}

			return bList;
		}

		/**
   * Counts number of bytes in string
   * @param {string} s
   * @return {array}
   */

	}, {
		key: 'stringByteCount',
		value: function stringByteCount(s) {
			return encodeURI(s).split(/%..|./).length - 1;
		}

		/**
   * Get an int from an array of bytes.
   * @param {array} bytes
   * @return {number}
   */

	}, {
		key: 'numberFromBytes',
		value: function numberFromBytes(bytes) {
			var hex = '';
			var stringResult;

			bytes.forEach(function (byte) {
				stringResult = byte.toString(16);

				// ensure string is 2 chars
				if (stringResult.length == 1) stringResult = "0" + stringResult;

				hex += stringResult;
			});

			return parseInt(hex, 16);
		}

		/**
   * Takes a number and splits it up into an array of bytes.  Can be padded by passing a number to bytesNeeded
   * @param {number} number
   * @param {number} bytesNeeded
   * @return {array} - Array of bytes
   */

	}, {
		key: 'numberToBytes',
		value: function numberToBytes(number, bytesNeeded) {
			bytesNeeded = bytesNeeded || 1;

			var hexString = number.toString(16);

			if (hexString.length & 1) {
				// Make sure hex string is even number of chars
				hexString = '0' + hexString;
			}

			// Split hex string into an array of two char elements
			var hexArray = hexString.match(/.{2}/g);

			// Now parse them out as integers
			hexArray = hexArray.map(function (item) {
				return parseInt(item, 16);
			});

			// Prepend empty bytes if we don't have enough
			if (hexArray.length < bytesNeeded) {
				while (bytesNeeded - hexArray.length > 0) {
					hexArray.unshift(0);
				}
			}

			return hexArray;
		}

		/**	
   * Converts value to array if needed.
   * @param {string} value
   * @return {array}
   */

	}, {
		key: 'toArray',
		value: function toArray(value) {
			if (Array.isArray(value)) return value;
			return [value];
		}
	}]);

	return Utils;
}();

exports.Utils = Utils;

var VexFlow = function () {
	function VexFlow() {
		_classCallCheck(this, VexFlow);
	}
	// code...


	/**
  * Support for converting VexFlow voice into MidiWriterJS track
  * @return MidiWritier.Track object
  */


	_createClass(VexFlow, [{
		key: 'trackFromVoice',
		value: function trackFromVoice(voice) {
			var track = new Track();
			var wait;
			var pitches = [];

			voice.tickables.forEach(function (tickable) {
				pitches = [];

				if (tickable.noteType === 'n') {
					tickable.keys.forEach(function (key) {
						// build array of pitches
						pitches.push(this.convertPitch(key));
					});
				} else if (tickable.noteType === 'r') {
					// move on to the next tickable and use this rest as a `wait` property for the next event
					wait = this.convertDuration(tickable);
					return;
				}

				track.addEvent(new NoteEvent({ pitch: pitches, duration: this.convertDuration(tickable), wait: wait }));

				// reset wait
				wait = 0;
			});

			return track;
		}

		/**
   * Converts VexFlow pitch syntax to MidiWriterJS syntax
   * @param pitch string
   */

	}, {
		key: 'convertPitch',
		value: function convertPitch(pitch) {
			return pitch.replace('/', '');
		}

		/**
   * Converts VexFlow duration syntax to MidiWriterJS syntax
   * @param note struct from VexFlow
   */

	}, {
		key: 'convertDuration',
		value: function convertDuration(note) {
			switch (note.duration) {
				case 'w':
					return '1';
				case 'h':
					return note.isDotted() ? 'd2' : '2';
				case 'q':
					return note.isDotted() ? 'd4' : '4';
				case '8':
					return note.isDotted() ? 'd8' : '8';
			}

			return note.duration;
		}
	}]);

	return VexFlow;
}();

exports.VexFlow = VexFlow;
/**
 * Object that puts together tracks and provides methods for file output.
 * @param {array} tracks - An array of {Track} objects.
 * @return {Writer}
 */

var Writer = function () {
	function Writer(tracks) {
		_classCallCheck(this, Writer);

		this.data = [];

		var trackType = tracks.length > 1 ? Constants.HEADER_CHUNK_FORMAT1 : Constants.HEADER_CHUNK_FORMAT0;
		var numberOfTracks = Utils.numberToBytes(tracks.length, 2); // two bytes long

		// Header chunk
		this.data.push(new Chunk({
			type: Constants.HEADER_CHUNK_TYPE,
			data: trackType.concat(numberOfTracks, Constants.HEADER_CHUNK_DIVISION) }));

		// Track chunks
		tracks.forEach(function (track, i) {
			track.addEvent(new MetaEvent({ data: Constants.META_END_OF_TRACK_ID }));
			this.data.push(track);
		}, this);
	}

	/**
  * Builds the file into a Uint8Array
  * @return {Uint8Array}
  */


	_createClass(Writer, [{
		key: 'buildFile',
		value: function buildFile() {
			var build = [];

			// Data consists of chunks which consists of data
			this.data.forEach(function (d) {
				return build = build.concat(d.type, d.size, d.data);
			});

			return new Uint8Array(build);
		}

		/**
   * Convert file buffer to a base64 string.  Different methods depending on if browser or node.
   * @return {string}
   */

	}, {
		key: 'base64',
		value: function base64() {
			if (typeof btoa === 'function') return btoa(String.fromCharCode.apply(null, this.buildFile()));
			return new Buffer(this.buildFile()).toString('base64');
		}

		/**
   * Get the data URI.
   * @return {string}
   */

	}, {
		key: 'dataUri',
		value: function dataUri() {
			return 'data:audio/midi;base64,' + this.base64();
		}

		/**
   * Output to stdout
   * @return {string}
   */

	}, {
		key: 'stdout',
		value: function stdout() {
			return process.stdout.write(new Buffer(this.buildFile()));
		}

		/**
   * Save to MIDI file
   * @param {string} filename
   */

	}, {
		key: 'saveMIDI',
		value: function saveMIDI(filename) {
			var buffer = new Buffer(this.buildFile());
			fs.writeFile(filename + '.mid', buffer, function (err) {
				if (err) return console.log(err);
			});
		}
	}]);

	return Writer;
}();

exports.Writer = Writer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbIkNodW5rIiwiZmllbGRzIiwidHlwZSIsImRhdGEiLCJzaXplIiwibGVuZ3RoIiwiQ29uc3RhbnRzIiwiVkVSU0lPTiIsIkhFQURFUl9DSFVOS19UWVBFIiwiSEVBREVSX0NIVU5LX0xFTkdUSCIsIkhFQURFUl9DSFVOS19GT1JNQVQwIiwiSEVBREVSX0NIVU5LX0ZPUk1BVDEiLCJIRUFERVJfQ0hVTktfRElWSVNJT04iLCJUUkFDS19DSFVOS19UWVBFIiwiTUVUQV9FVkVOVF9JRCIsIk1FVEFfVEVYVF9JRCIsIk1FVEFfQ09QWVJJR0hUX0lEIiwiTUVUQV9UUkFDS19OQU1FX0lEIiwiTUVUQV9JTlNUUlVNRU5UX05BTUVfSUQiLCJNRVRBX0xZUklDX0lEIiwiTUVUQV9NQVJLRVJfSUQiLCJNRVRBX0NVRV9QT0lOVCIsIk1FVEFfVEVNUE9fSUQiLCJNRVRBX1NNVFBFX09GRlNFVCIsIk1FVEFfVElNRV9TSUdOQVRVUkVfSUQiLCJNRVRBX0tFWV9TSUdOQVRVUkVfSUQiLCJNRVRBX0VORF9PRl9UUkFDS19JRCIsIlBST0dSQU1fQ0hBTkdFX1NUQVRVUyIsIk1ldGFFdmVudCIsIlV0aWxzIiwibnVtYmVyVG9WYXJpYWJsZUxlbmd0aCIsImNvbmNhdCIsIk5vdGVFdmVudCIsInBpdGNoIiwidG9BcnJheSIsIndhaXQiLCJkdXJhdGlvbiIsInNlcXVlbnRpYWwiLCJ2ZWxvY2l0eSIsImNoYW5uZWwiLCJyZXBlYXQiLCJjb252ZXJ0VmVsb2NpdHkiLCJncmFjZSIsImJ1aWxkRGF0YSIsInRpY2tEdXJhdGlvbiIsImdldFRpY2tEdXJhdGlvbiIsInJlc3REdXJhdGlvbiIsImdyYWNlRHVyYXRpb24iLCJmb3JFYWNoIiwibm90ZUV2ZW50Iiwibm90ZU9uIiwibm90ZU9mZiIsIkFycmF5IiwiaXNBcnJheSIsImoiLCJwIiwiaSIsIk5vdGVPbkV2ZW50IiwiZ2V0Tm90ZU9uU3RhdHVzIiwiZ2V0UGl0Y2giLCJOb3RlT2ZmRXZlbnQiLCJnZXROb3RlT2ZmU3RhdHVzIiwicXVhcnRlclRpY2tzIiwibnVtYmVyRnJvbUJ5dGVzIiwiTWF0aCIsInJvdW5kIiwibWFwIiwidmFsdWUiLCJyZWR1Y2UiLCJhIiwiYiIsInRvU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJjaGFyQXQiLCJwYXJzZUludCIsInN1YnN0cmluZyIsImdldER1cmF0aW9uTXVsdGlwbGllciIsIlByb2dyYW1DaGFuZ2VFdmVudCIsImluc3RydW1lbnQiLCJUcmFjayIsImV2ZW50cyIsImV2ZW50IiwibWFwRnVuY3Rpb24iLCJlIiwicHJvcGVydGllcyIsIm51bWJlclRvQnl0ZXMiLCJwdXNoIiwiYnBtIiwidGVtcG8iLCJhZGRFdmVudCIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwibWlkaWNsb2Nrc3BlcnRpY2siLCJub3Rlc3Blcm1pZGljbG9jayIsIl9kZW5vbWluYXRvciIsImxvZzIiLCJzZiIsIm1pIiwibW9kZSIsImZpZnRocyIsIl9zZmxlbiIsIm5vdGUiLCJ0b1VwcGVyQ2FzZSIsImZpZnRoaW5kZXgiLCJpbmRleE9mIiwidGV4dCIsInN0cmluZ0J5dGVzIiwic3RyaW5nVG9CeXRlcyIsImx5cmljIiwic3RyaW5nIiwic3BsaXQiLCJjaGFyIiwiY2hhckNvZGVBdCIsIm4iLCJpc05hTiIsInBhcnNlRmxvYXQiLCJpc0Zpbml0ZSIsInRpY2tzIiwiYnVmZmVyIiwiYkxpc3QiLCJzIiwiZW5jb2RlVVJJIiwiYnl0ZXMiLCJoZXgiLCJzdHJpbmdSZXN1bHQiLCJieXRlIiwibnVtYmVyIiwiYnl0ZXNOZWVkZWQiLCJoZXhTdHJpbmciLCJoZXhBcnJheSIsIm1hdGNoIiwiaXRlbSIsInVuc2hpZnQiLCJWZXhGbG93Iiwidm9pY2UiLCJ0cmFjayIsInBpdGNoZXMiLCJ0aWNrYWJsZXMiLCJ0aWNrYWJsZSIsIm5vdGVUeXBlIiwia2V5cyIsImtleSIsImNvbnZlcnRQaXRjaCIsImNvbnZlcnREdXJhdGlvbiIsInJlcGxhY2UiLCJpc0RvdHRlZCIsIldyaXRlciIsInRyYWNrcyIsInRyYWNrVHlwZSIsIm51bWJlck9mVHJhY2tzIiwiYnVpbGQiLCJkIiwiVWludDhBcnJheSIsImJ0b2EiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsImJ1aWxkRmlsZSIsIkJ1ZmZlciIsImJhc2U2NCIsInByb2Nlc3MiLCJzdGRvdXQiLCJ3cml0ZSIsImZpbGVuYW1lIiwiZnMiLCJ3cml0ZUZpbGUiLCJlcnIiLCJjb25zb2xlIiwibG9nIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQXVqQkE7Ozs7QUF2akJBOzs7OztJQUtNQSxLLEdBQ0wsZUFBWUMsTUFBWixFQUFvQjtBQUFBOztBQUNuQixNQUFLQyxJQUFMLEdBQVlELE9BQU9DLElBQW5CO0FBQ0EsTUFBS0MsSUFBTCxHQUFZRixPQUFPRSxJQUFuQjtBQUNBLE1BQUtDLElBQUwsR0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVSCxPQUFPRSxJQUFQLENBQVlFLE1BQXRCLENBQVo7QUFDQSxDOztRQUdNTCxLLEdBQUFBLEs7QUFDUjs7Ozs7QUFLQSxJQUFJTSxZQUFZO0FBQ2ZDLFVBQWMsT0FEQztBQUVmQyxvQkFBdUIsQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsRUFBbUIsSUFBbkIsQ0FGUixFQUVrQztBQUNqREMsc0JBQXdCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLENBSFQsRUFHbUM7QUFDbERDLHVCQUEwQixDQUFDLElBQUQsRUFBTyxJQUFQLENBSlgsRUFJeUI7QUFDeENDLHVCQUEwQixDQUFDLElBQUQsRUFBTyxJQUFQLENBTFgsRUFLeUI7QUFDeENDLHdCQUEwQixDQUFDLElBQUQsRUFBTyxJQUFQLENBTlgsRUFNeUI7QUFDeENDLG1CQUFvQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixDQVBMLEVBTytCO0FBQzlDQyxnQkFBa0IsSUFSSDtBQVNmQyxlQUFpQixJQVRGO0FBVWZDLG9CQUFxQixJQVZOO0FBV2ZD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LElBQUl3QyxNQUFKLENBQVcsS0FBS0QsU0FBTCxFQUFYLENBQWI7QUFDQU8sTUFBR0MsU0FBSCxDQUFhRixXQUFXLE1BQXhCLEVBQWdDN0MsTUFBaEMsRUFBd0MsVUFBVWdELEdBQVYsRUFBZTtBQUN0RCxRQUFHQSxHQUFILEVBQVEsT0FBT0MsUUFBUUMsR0FBUixDQUFZRixHQUFaLENBQVA7QUFDUixJQUZEO0FBR0E7Ozs7OztRQUdNcEIsTSxHQUFBQSxNIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNodW5rIHNlY3Rpb24gb2YgYSBNSURJIGZpbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gZmllbGRzIC0ge3R5cGU6IG51bWJlciwgZGF0YTogYXJyYXksIHNpemU6IGFycmF5fVxuICogQHJldHVybiB7Q2h1bmt9XG4gKi9cbmNsYXNzIENodW5rIHtcblx0Y29uc3RydWN0b3IoZmllbGRzKSB7XG5cdFx0dGhpcy50eXBlID0gZmllbGRzLnR5cGU7XG5cdFx0dGhpcy5kYXRhID0gZmllbGRzLmRhdGE7XG5cdFx0dGhpcy5zaXplID0gWzAsIDAsIDAsIGZpZWxkcy5kYXRhLmxlbmd0aF07XG5cdH1cbn1cblxuZXhwb3J0IHtDaHVua307XG4vKipcbiAqIE1JREkgZmlsZSBmb3JtYXQgY29uc3RhbnRzLCBpbmNsdWRpbmcgbm90ZSAtPiBNSURJIG51bWJlciB0cmFuc2xhdGlvbi5cbiAqIEByZXR1cm4ge0NvbnN0YW50c31cbiAqL1xuXG52YXIgQ29uc3RhbnRzID0ge1xuXHRWRVJTSU9OXHRcdFx0XHRcdDogJzEuNS4xJyxcblx0SEVBREVSX0NIVU5LX1RZUEUgIFx0XHQ6IFsweDRkLCAweDU0LCAweDY4LCAweDY0XSwgLy8gTXRoZFxuXHRIRUFERVJfQ0hVTktfTEVOR1RIICBcdDogWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDZdLCAvLyBIZWFkZXIgc2l6ZSBmb3IgU01GXG5cdEhFQURFUl9DSFVOS19GT1JNQVQwICAgIDogWzB4MDAsIDB4MDBdLCAvLyBNaWRpIFR5cGUgMCBpZFxuXHRIRUFERVJfQ0hVTktfRk9STUFUMSAgICA6IFsweDAwLCAweDAxXSwgLy8gTWlkaSBUeXBlIDEgaWRcblx0SEVBREVSX0NIVU5LX0RJVklTSU9OICAgOiBbMHgwMCwgMHg4MF0sIC8vIERlZmF1bHRzIHRvIDEyOCB0aWNrcyBwZXIgYmVhdFxuXHRUUkFDS19DSFVOS19UWVBFXHRcdDogWzB4NGQsIDB4NTQsIDB4NzIsIDB4NmJdLCAvLyBNVHJrLFxuXHRNRVRBX0VWRU5UX0lEXHRcdFx0OiAweEZGLFxuXHRNRVRBX1RFWFRfSURcdFx0XHQ6IDB4MDEsXG5cdE1FVEFfQ09QWVJJR0hUX0lEXHRcdDogMHgwMixcblx0TUVUQV9UUkFDS19OQU1FX0lEXHRcdDogMHgwMyxcblx0TUVUQV9JTlNUUlVNRU5UX05BTUVfSUQgOiAweDA0LFxuXHRNRVRBX0xZUklDX0lEXHRcdFx0OiAweDA1LFxuXHRNRVRBX01BUktFUl9JRFx0XHRcdDogMHgwNixcblx0TUVUQV9DVUVfUE9JTlRcdFx0XHQ6IDB4MDcsXG5cdE1FVEFfVEVNUE9fSURcdFx0XHQ6IDB4NTEsXG5cdE1FVEFfU01UUEVfT0ZGU0VUXHRcdDogMHg1NCxcblx0TUVUQV9USU1FX1NJR05BVFVSRV9JRFx0OiAweDU4LFxuXHRNRVRBX0tFWV9TSUdOQVRVUkVfSURcdDogMHg1OSxcblx0TUVUQV9FTkRfT0ZfVFJBQ0tfSURcdDogWzB4MkYsIDB4MDBdLFxuXHRQUk9HUkFNX0NIQU5HRV9TVEFUVVNcdDogMHhDMCwgLy8gaW5jbHVkZXMgY2hhbm5lbCBudW1iZXIgKDApXG59O1xuXG5leHBvcnQge0NvbnN0YW50c307XG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIG1ldGEgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gZmllbGRzIC0gdHlwZSwgZGF0YVxuICogQHJldHVybiB7TWV0YUV2ZW50fVxuICovXG5jbGFzcyBNZXRhRXZlbnQge1xuXHRjb25zdHJ1Y3RvcihmaWVsZHMpIHtcblx0XHR0aGlzLnR5cGUgPSAnbWV0YSc7XG5cdFx0dGhpcy5kYXRhID0gVXRpbHMubnVtYmVyVG9WYXJpYWJsZUxlbmd0aCgweDAwKTsvLyBTdGFydCB3aXRoIHplcm8gdGltZSBkZWx0YVxuXHRcdHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5jb25jYXQoQ29uc3RhbnRzLk1FVEFfRVZFTlRfSUQsIGZpZWxkcy5kYXRhKTtcblx0fVxufVxuXG5leHBvcnQge01ldGFFdmVudH07XG4vKipcbiAqIFdyYXBwZXIgZm9yIG5vdGVPbkV2ZW50L25vdGVPZmZFdmVudCBvYmplY3RzIHRoYXQgYnVpbGRzIGJvdGggZXZlbnRzLlxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkcyAtIHtwaXRjaDogJ1tDNF0nLCBkdXJhdGlvbjogJzQnLCB3YWl0OiAnNCcsIHZlbG9jaXR5OiAxLTEwMH1cbiAqIEByZXR1cm4ge05vdGVFdmVudH1cbiAqL1xuY2xhc3MgTm90ZUV2ZW50IHtcblx0Y29uc3RydWN0b3IoZmllbGRzKSB7XG5cdFx0dGhpcy50eXBlIFx0XHQ9ICdub3RlJztcblx0XHR0aGlzLnBpdGNoIFx0XHQ9IFV0aWxzLnRvQXJyYXkoZmllbGRzLnBpdGNoKTtcblx0XHR0aGlzLndhaXQgXHRcdD0gZmllbGRzLndhaXQgfHwgMDtcblx0XHR0aGlzLmR1cmF0aW9uIFx0PSBmaWVsZHMuZHVyYXRpb247XG5cdFx0dGhpcy5zZXF1ZW50aWFsID0gZmllbGRzLnNlcXVlbnRpYWwgfHwgZmFsc2U7XG5cdFx0dGhpcy52ZWxvY2l0eSBcdD0gZmllbGRzLnZlbG9jaXR5IHx8IDUwO1xuXHRcdHRoaXMuY2hhbm5lbCBcdD0gZmllbGRzLmNoYW5uZWwgfHwgMTtcblx0XHR0aGlzLnJlcGVhdCBcdD0gZmllbGRzLnJlcGVhdCB8fCAxO1xuXHRcdHRoaXMudmVsb2NpdHkgXHQ9IHRoaXMuY29udmVydFZlbG9jaXR5KHRoaXMudmVsb2NpdHkpO1xuXHRcdHRoaXMuZ3JhY2VcdFx0PSBmaWVsZHMuZ3JhY2U7XG5cdFx0dGhpcy5idWlsZERhdGEoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCdWlsZHMgaW50IGFycmF5IGZvciB0aGlzIGV2ZW50LlxuXHQgKiBAcmV0dXJuIHtOb3RlRXZlbnR9XG5cdCAqL1xuXHRidWlsZERhdGEoKSB7XG5cdFx0dGhpcy5kYXRhID0gW107XG5cblx0XHR2YXIgdGlja0R1cmF0aW9uID0gdGhpcy5nZXRUaWNrRHVyYXRpb24odGhpcy5kdXJhdGlvbiwgJ25vdGUnKTtcblx0XHR2YXIgcmVzdER1cmF0aW9uID0gdGhpcy5nZXRUaWNrRHVyYXRpb24odGhpcy53YWl0LCAncmVzdCcpO1xuXG5cdFx0Ly8gQXBwbHkgZ3JhY2Ugbm90ZShzKSBhbmQgc3VidHJhY3QgdGlja3MgKGN1cnJlbnRseSAxIHRpY2sgcGVyIGdyYWNlIG5vdGUpIGZyb20gdGlja0R1cmF0aW9uIHNvIG5ldCB2YWx1ZSBpcyB0aGUgc2FtZVxuXHRcdGlmICh0aGlzLmdyYWNlKSB7XG5cdFx0XHRsZXQgZ3JhY2VEdXJhdGlvbiA9IDE7XG5cdFx0XHR0aGlzLmdyYWNlID0gVXRpbHMudG9BcnJheSh0aGlzLmdyYWNlKTtcblx0XHRcdHRoaXMuZ3JhY2UuZm9yRWFjaChmdW5jdGlvbihwaXRjaCkge1xuXHRcdFx0XHRsZXQgbm90ZUV2ZW50ID0gbmV3IE5vdGVFdmVudCh7cGl0Y2g6dGhpcy5ncmFjZSwgZHVyYXRpb246J1QnICsgZ3JhY2VEdXJhdGlvbn0pO1xuXHRcdFx0XHR0aGlzLmRhdGEgPSB0aGlzLmRhdGEuY29uY2F0KG5vdGVFdmVudC5kYXRhKVxuXG5cdFx0XHRcdHRpY2tEdXJhdGlvbiAtPSBncmFjZUR1cmF0aW9uO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gZmllbGRzLnBpdGNoIGNvdWxkIGJlIGFuIGFycmF5IG9mIHBpdGNoZXMuXG5cdFx0Ly8gSWYgc28gY3JlYXRlIG5vdGUgZXZlbnRzIGZvciBlYWNoIGFuZCBhcHBseSB0aGUgc2FtZSBkdXJhdGlvbi5cblx0XHR2YXIgbm90ZU9uLCBub3RlT2ZmO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHRoaXMucGl0Y2gpKSB7XG5cdFx0XHQvLyBCeSBkZWZhdWx0IHRoaXMgaXMgYSBjaG9yZCBpZiBpdCdzIGFuIGFycmF5IG9mIG5vdGVzIHRoYXQgcmVxdWlyZXMgb25lIE5vdGVPbkV2ZW50LlxuXHRcdFx0Ly8gSWYgdGhpcy5zZXF1ZW50aWFsID09PSB0cnVlIHRoZW4gaXQncyBhIHNlcXVlbnRpYWwgc3RyaW5nIG9mIG5vdGVzIHRoYXQgcmVxdWlyZXMgc2VwYXJhdGUgTm90ZU9uRXZlbnRzLlxuXHRcdFx0aWYgKCAhIHRoaXMuc2VxdWVudGlhbCkge1xuXHRcdFx0XHQvLyBIYW5kbGUgcmVwZWF0XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5yZXBlYXQ7IGorKykge1xuXHRcdFx0XHRcdC8vIE5vdGUgb25cblx0XHRcdFx0XHR0aGlzLnBpdGNoLmZvckVhY2goZnVuY3Rpb24ocCwgaSkge1xuXHRcdFx0XHRcdFx0aWYgKGkgPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRub3RlT24gPSBuZXcgTm90ZU9uRXZlbnQoe2RhdGE6IFV0aWxzLm51bWJlclRvVmFyaWFibGVMZW5ndGgocmVzdER1cmF0aW9uKS5jb25jYXQodGhpcy5nZXROb3RlT25TdGF0dXMoKSwgVXRpbHMuZ2V0UGl0Y2gocCksIHRoaXMudmVsb2NpdHkpfSk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJ1bm5pbmcgc3RhdHVzIChjYW4gb21taXQgdGhlIG5vdGUgb24gc3RhdHVzKVxuXHRcdFx0XHRcdFx0XHRub3RlT24gPSBuZXcgTm90ZU9uRXZlbnQoe2RhdGE6IFswLCBVdGlscy5nZXRQaXRjaChwKSwgdGhpcy52ZWxvY2l0eV19KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChub3RlT24uZGF0YSk7XG5cdFx0XHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdFx0XHQvLyBOb3RlIG9mZlxuXHRcdFx0XHRcdHRoaXMucGl0Y2guZm9yRWFjaChmdW5jdGlvbihwLCBpKSB7XG5cdFx0XHRcdFx0XHRpZiAoaSA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdG5vdGVPZmYgPSBuZXcgTm90ZU9mZkV2ZW50KHtkYXRhOiBVdGlscy5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKHRpY2tEdXJhdGlvbikuY29uY2F0KHRoaXMuZ2V0Tm90ZU9mZlN0YXR1cygpLCBVdGlscy5nZXRQaXRjaChwKSwgdGhpcy52ZWxvY2l0eSl9KTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUnVubmluZyBzdGF0dXMgKGNhbiBvbW1pdCB0aGUgbm90ZSBvZmYgc3RhdHVzKVxuXHRcdFx0XHRcdFx0XHRub3RlT2ZmID0gbmV3IE5vdGVPZmZFdmVudCh7ZGF0YTogWzAsIFV0aWxzLmdldFBpdGNoKHApLCB0aGlzLnZlbG9jaXR5XX0pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEgPSB0aGlzLmRhdGEuY29uY2F0KG5vdGVPZmYuZGF0YSk7XG5cdFx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSGFuZGxlIHJlcGVhdFxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMucmVwZWF0OyBqKyspIHtcblx0XHRcdFx0XHR0aGlzLnBpdGNoLmZvckVhY2goZnVuY3Rpb24ocCwgaSkge1xuXHRcdFx0XHRcdFx0Ly8gcmVzdER1cmF0aW9uIG9ubHkgYXBwbGllcyB0byBmaXJzdCBub3RlXG5cdFx0XHRcdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0XHRcdFx0cmVzdER1cmF0aW9uID0gMDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSWYgZHVyYXRpb24gaXMgOHRoIHRyaXBsZXRzIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHRvdGFsIHRpY2tzID09IHF1YXJ0ZXIgbm90ZS5cblx0XHRcdFx0XHRcdC8vIFNvLCB0aGUgbGFzdCBvbmUgd2lsbCBuZWVkIHRvIGJlIHRoZSByZW1haW5kZXJcblx0XHRcdFx0XHRcdGlmICh0aGlzLmR1cmF0aW9uID09PSAnOHQnICYmIGkgPT0gdGhpcy5waXRjaC5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBxdWFydGVyVGlja3MgPSBVdGlscy5udW1iZXJGcm9tQnl0ZXMoQ29uc3RhbnRzLkhFQURFUl9DSFVOS19ESVZJU0lPTik7XG5cdFx0XHRcdFx0XHRcdHRpY2tEdXJhdGlvbiA9IHF1YXJ0ZXJUaWNrcyAtICh0aWNrRHVyYXRpb24gKiAyKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bm90ZU9uID0gbmV3IE5vdGVPbkV2ZW50KHtkYXRhOiBVdGlscy5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKHJlc3REdXJhdGlvbikuY29uY2F0KFt0aGlzLmdldE5vdGVPblN0YXR1cygpLCBVdGlscy5nZXRQaXRjaChwKSwgdGhpcy52ZWxvY2l0eV0pfSk7XG5cdFx0XHRcdFx0XHRub3RlT2ZmID0gbmV3IE5vdGVPZmZFdmVudCh7ZGF0YTogVXRpbHMubnVtYmVyVG9WYXJpYWJsZUxlbmd0aCh0aWNrRHVyYXRpb24pLmNvbmNhdChbdGhpcy5nZXROb3RlT2ZmU3RhdHVzKCksIFV0aWxzLmdldFBpdGNoKHApLCB0aGlzLnZlbG9jaXR5XSl9KTtcblxuXHRcdFx0XHRcdFx0dGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChub3RlT24uZGF0YSwgbm90ZU9mZi5kYXRhKTtcblx0XHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0aHJvdyAncGl0Y2ggbXVzdCBiZSBhbiBhcnJheS4nO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB2ZWxvY2l0eSB0byB2YWx1ZSAwLTEyN1xuXHQgKiBAcGFyYW0ge251bWJlcn0gdmVsb2NpdHkgLSBWZWxvY2l0eSB2YWx1ZSAxLTEwMFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRjb252ZXJ0VmVsb2NpdHkodmVsb2NpdHkpIHtcblx0XHQvLyBNYXggcGFzc2VkIHZhbHVlIGxpbWl0ZWQgdG8gMTAwXG5cdFx0dmVsb2NpdHkgPSB2ZWxvY2l0eSA+IDEwMCA/IDEwMCA6IHZlbG9jaXR5O1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKHZlbG9jaXR5IC8gMTAwICogMTI3KTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHBhc3NlZCBkdXJhdGlvbi5cblx0ICogTm90ZTogdHlwZT09J25vdGUnIGRlZmF1bHRzIHRvIHF1YXJ0ZXIgbm90ZSwgdHlwZT09PSdyZXN0JyBkZWZhdWx0cyB0byAwXG5cdCAqIEBwYXJhbSB7KHN0cmluZ3xhcnJheSl9IGR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFsnbm90ZScsICdyZXN0J11cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0Z2V0VGlja0R1cmF0aW9uKGR1cmF0aW9uLCB0eXBlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZHVyYXRpb24pKSB7XG5cdFx0XHQvLyBSZWN1cnNpdmVseSBleGVjdXRlIHRoaXMgbWV0aG9kIGZvciBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5IGFuZCByZXR1cm4gdGhlIHN1bSBvZiB0aWNrIGR1cmF0aW9ucy5cblx0XHRcdHJldHVybiBkdXJhdGlvbi5tYXAoZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VGlja0R1cmF0aW9uKHZhbHVlLCB0eXBlKTtcblx0XHRcdH0sIHRoaXMpLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhICsgYjtcblx0XHRcdH0sIDApO1xuXHRcdH1cblxuXHRcdGR1cmF0aW9uID0gZHVyYXRpb24udG9TdHJpbmcoKTtcblxuXHRcdGlmIChkdXJhdGlvbi50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3QnKSB7XG5cdFx0XHQvLyBJZiBkdXJhdGlvbiBzdGFydHMgd2l0aCAndCcgdGhlbiB0aGUgbnVtYmVyIHRoYXQgZm9sbG93cyBpcyBhbiBleHBsaWNpdCB0aWNrIGNvdW50XG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQoZHVyYXRpb24uc3Vic3RyaW5nKDEpKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkIHRvIGFwcGx5IGR1cmF0aW9uIGhlcmUuICBRdWFydGVyIG5vdGUgPT0gQ29uc3RhbnRzLkhFQURFUl9DSFVOS19ESVZJU0lPTlxuXHRcdC8vIFJvdW5kaW5nIG9ubHkgYXBwbGllcyB0byB0cmlwbGV0cywgd2hpY2ggdGhlIHJlbWFpbmRlciBpcyBoYW5kbGVkIGJlbG93XG5cdFx0dmFyIHF1YXJ0ZXJUaWNrcyA9IFV0aWxzLm51bWJlckZyb21CeXRlcyhDb25zdGFudHMuSEVBREVSX0NIVU5LX0RJVklTSU9OKTtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZChxdWFydGVyVGlja3MgKiB0aGlzLmdldER1cmF0aW9uTXVsdGlwbGllcihkdXJhdGlvbiwgdHlwZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgd2hhdCB0byBtdWx0aXBsZSB0aWNrcy9xdWFydGVyIG5vdGUgYnkgdG8gZ2V0IHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG5cdCAqIE5vdGU6IHR5cGU9PSdub3RlJyBkZWZhdWx0cyB0byBxdWFydGVyIG5vdGUsIHR5cGU9PT0ncmVzdCcgZGVmYXVsdHMgdG8gMFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZHVyYXRpb25cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgWydub3RlJywncmVzdCddXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdGdldER1cmF0aW9uTXVsdGlwbGllcihkdXJhdGlvbiwgdHlwZSkge1xuXHRcdC8vIE5lZWQgdG8gYXBwbHkgZHVyYXRpb24gaGVyZS4gIFF1YXJ0ZXIgbm90ZSA9PSBDb25zdGFudHMuSEVBREVSX0NIVU5LX0RJVklTSU9OXG5cdFx0c3dpdGNoIChkdXJhdGlvbikge1xuXHRcdFx0Y2FzZSAnMCc6XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0Y2FzZSAnMSc6XG5cdFx0XHRcdHJldHVybiA0O1xuXHRcdFx0Y2FzZSAnMic6XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0Y2FzZSAnZDInOlxuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdGNhc2UgJzQnOlxuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdGNhc2UgJzR0Jzpcblx0XHRcdFx0cmV0dXJuIDAuNjY2O1xuXHRcdFx0Y2FzZSAnZDQnOlxuXHRcdFx0XHRyZXR1cm4gMS41O1xuXHRcdFx0Y2FzZSAnOCc6XG5cdFx0XHRcdHJldHVybiAwLjU7XG5cdFx0XHRjYXNlICc4dCc6XG5cdFx0XHRcdC8vIEZvciA4dGggdHJpcGxldHMsIGxldCdzIGRpdmlkZSBhIHF1YXJ0ZXIgYnkgMywgcm91bmQgdG8gdGhlIG5lYXJlc3QgaW50LCBhbmQgc3Vic3RyYWN0IHRoZSByZW1haW5kZXIgdG8gdGhlIGxhc3Qgb25lLlxuXHRcdFx0XHRyZXR1cm4gMC4zMztcblx0XHRcdGNhc2UgJ2Q4Jzpcblx0XHRcdFx0cmV0dXJuIDAuNzU7XG5cdFx0XHRjYXNlICcxNic6XG5cdFx0XHRcdHJldHVybiAwLjI1O1xuXHRcdFx0Y2FzZSAnMTZ0Jzpcblx0XHRcdFx0cmV0dXJuIDAuMTY2O1xuXHRcdFx0Y2FzZSAnMzInOlxuXHRcdFx0XHRyZXR1cm4gMC4xMjU7XG5cdFx0XHRjYXNlICc2NCc6XG5cdFx0XHRcdHJldHVybiAwLjA2MjU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHQvLyBOb3RlcyBkZWZhdWx0IHRvIGEgcXVhcnRlciwgcmVzdHMgZGVmYXVsdCB0byAwXG5cdFx0XHRcdC8vcmV0dXJuIHR5cGUgPT09ICdub3RlJyA/IDEgOiAwO1xuXHRcdH1cblxuXHRcdHRocm93IGR1cmF0aW9uICsgJyBpcyBub3QgYSB2YWxpZCBkdXJhdGlvbi4nO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBub3RlIG9uIHN0YXR1cyBjb2RlIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBjaGFubmVsLiAweDl7MC1GfVxuXHQgKiBOb3RlIG9uIGF0IGNoYW5uZWwgMCBpcyAweDkwICgxNDQpXG5cdCAqIDAgPSBDaCAxXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdGdldE5vdGVPblN0YXR1cygpIHtyZXR1cm4gMTQ0ICsgdGhpcy5jaGFubmVsIC0gMX1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgbm90ZSBvZmYgc3RhdHVzIGNvZGUgYmFzZWQgb24gdGhlIHNlbGVjdGVkIGNoYW5uZWwuIDB4OHswLUZ9XG5cdCAqIE5vdGUgb2ZmIGF0IGNoYW5uZWwgMCBpcyAweDgwICgxMjgpXG5cdCAqIDAgPSBDaCAxXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdGdldE5vdGVPZmZTdGF0dXMoKSB7cmV0dXJuIDEyOCArIHRoaXMuY2hhbm5lbCAtIDF9XG59XG5cbmV4cG9ydCB7Tm90ZUV2ZW50fTtcbi8qKlxuICogSG9sZHMgYWxsIGRhdGEgZm9yIGEgXCJub3RlIG9mZlwiIE1JREkgZXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZHMge2RhdGE6IFtdfVxuICogQHJldHVybiB7Tm90ZU9mZkV2ZW50fVxuICovXG5jbGFzcyBOb3RlT2ZmRXZlbnQge1xuXHRjb25zdHJ1Y3RvcihmaWVsZHMpIHtcblx0XHR0aGlzLmRhdGEgPSBmaWVsZHMuZGF0YTtcblx0fVxufVxuXG5leHBvcnQge05vdGVPZmZFdmVudH07XG4vKipcbiAqIEhvbGRzIGFsbCBkYXRhIGZvciBhIFwibm90ZSBvblwiIE1JREkgZXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZHMge2RhdGE6IFtdfVxuICogQHJldHVybiB7Tm90ZU9uRXZlbnR9XG4gKi9cbmNsYXNzIE5vdGVPbkV2ZW50IHtcblx0Y29uc3RydWN0b3IoZmllbGRzKSB7XG5cdFx0dGhpcy5kYXRhID0gZmllbGRzLmRhdGE7XG5cdH1cbn1cblxuZXhwb3J0IHtOb3RlT25FdmVudH07XG4vKipcbiAqIEhvbGRzIGFsbCBkYXRhIGZvciBhIFwicHJvZ3JhbSBjaGFuZ2VcIiBNSURJIGV2ZW50XG4gKiBAcGFyYW0ge29iamVjdH0gZmllbGRzIHt0eXBlOiBzdHJpbmcsIGRhdGE6IFtdfVxuICogQHJldHVybiB7Tm90ZU9mZkV2ZW50fVxuICovXG5jbGFzcyBQcm9ncmFtQ2hhbmdlRXZlbnQge1xuXHRjb25zdHJ1Y3RvcihmaWVsZHMpIHtcblx0XHR0aGlzLnR5cGUgPSAncHJvZ3JhbSc7XG5cdFx0Ly8gZGVsdGEgdGltZSBkZWZhdWx0cyB0byAwLlxuXHRcdHRoaXMuZGF0YSA9IFV0aWxzLm51bWJlclRvVmFyaWFibGVMZW5ndGgoMHgwMCkuY29uY2F0KENvbnN0YW50cy5QUk9HUkFNX0NIQU5HRV9TVEFUVVMsIGZpZWxkcy5pbnN0cnVtZW50KTtcblx0fVxufVxuXG5leHBvcnQge1Byb2dyYW1DaGFuZ2VFdmVudH07XG4vKipcbiAqIEhvbGRzIGFsbCBkYXRhIGZvciBhIHRyYWNrLlxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkcyB7dHlwZTogbnVtYmVyLCBkYXRhOiBhcnJheSwgc2l6ZTogYXJyYXksIGV2ZW50czogYXJyYXl9XG4gKiBAcmV0dXJuIHtUcmFja31cbiAqL1xuY2xhc3MgVHJhY2sge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLnR5cGUgPSBDb25zdGFudHMuVFJBQ0tfQ0hVTktfVFlQRTtcblx0XHR0aGlzLmRhdGEgPSBbXTtcblx0XHR0aGlzLnNpemUgPSBbXTtcblx0XHR0aGlzLmV2ZW50cyA9IFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW55IGV2ZW50IHR5cGUgdG8gdGhlIHRyYWNrLlxuXHQgKiBAcGFyYW0geyhOb3RlRXZlbnR8TWV0YUV2ZW50fFByb2dyYW1DaGFuZ2VFdmVudCl9IGV2ZW50IC0gRXZlbnQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtYXBGdW5jdGlvbiAtIENhbGxiYWNrIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGFwcGx5IHNwZWNpZmljIHByb3BlcnRpZXMgdG8gYWxsIGV2ZW50cy4gXG5cdCAqIEByZXR1cm4ge1RyYWNrfVxuXHQgKi9cblx0YWRkRXZlbnQoZXZlbnQsIG1hcEZ1bmN0aW9uKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG5cdFx0XHRldmVudC5mb3JFYWNoKGZ1bmN0aW9uKGUsIGkpIHtcblx0XHRcdFx0Ly8gSGFuZGxlIG1hcCBmdW5jdGlvbiBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAodHlwZW9mIG1hcEZ1bmN0aW9uID09PSAnZnVuY3Rpb24nICYmIGUudHlwZSA9PT0gJ25vdGUnKSB7XG5cdFx0XHRcdFx0dmFyIHByb3BlcnRpZXMgPSBtYXBGdW5jdGlvbihpLCBlKTtcblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgcHJvcGVydGllcyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGogaW4gcHJvcGVydGllcykge1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2goaikge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2R1cmF0aW9uJzpcblx0XHRcdFx0XHRcdFx0XHRcdGUuZHVyYXRpb24gPSBwcm9wZXJ0aWVzW2pdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnc2VxdWVudGlhbCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRlLnNlcXVlbnRpYWwgPSBwcm9wZXJ0aWVzW2pdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAndmVsb2NpdHknOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZS52ZWxvY2l0eSA9IGUuY29udmVydFZlbG9jaXR5KHByb3BlcnRpZXNbal0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cdFx0XG5cblx0XHRcdFx0XHRcdC8vIEdvdHRhIGJ1aWxkIHRoYXQgZGF0YVxuXHRcdFx0XHRcdFx0ZS5idWlsZERhdGEoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmRhdGEgPSB0aGlzLmRhdGEuY29uY2F0KGUuZGF0YSk7XG5cdFx0XHRcdHRoaXMuc2l6ZSA9IFV0aWxzLm51bWJlclRvQnl0ZXModGhpcy5kYXRhLmxlbmd0aCwgNCk7IC8vIDQgYnl0ZXMgbG9uZ1xuXHRcdFx0XHR0aGlzLmV2ZW50cy5wdXNoKGUpO1xuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChldmVudC5kYXRhKTtcblx0XHRcdHRoaXMuc2l6ZSA9IFV0aWxzLm51bWJlclRvQnl0ZXModGhpcy5kYXRhLmxlbmd0aCwgNCk7IC8vIDQgYnl0ZXMgbG9uZ1xuXHRcdFx0dGhpcy5ldmVudHMucHVzaChldmVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0ZW1wbyBvZiB0aGUgTUlESSBmaWxlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYnBtIC0gVGVtcG8gaW4gYmVhdHMgcGVyIG1pbnV0ZS5cblx0ICogQHJldHVybiB7VHJhY2t9XG5cdCAqL1xuXHRzZXRUZW1wbyhicG0pIHtcblx0XHR2YXIgZXZlbnQgPSBuZXcgTWV0YUV2ZW50KHtkYXRhOiBbQ29uc3RhbnRzLk1FVEFfVEVNUE9fSURdfSk7XG5cdFx0ZXZlbnQuZGF0YS5wdXNoKDB4MDMpOyAvLyBTaXplXG5cdFx0dmFyIHRlbXBvID0gTWF0aC5yb3VuZCg2MDAwMDAwMCAvIGJwbSk7XG5cdFx0ZXZlbnQuZGF0YSA9IGV2ZW50LmRhdGEuY29uY2F0KFV0aWxzLm51bWJlclRvQnl0ZXModGVtcG8sIDMpKTsgLy8gVGVtcG8sIDMgYnl0ZXNcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudChldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aW1lIHNpZ25hdHVyZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG51bWVyYXRvciAtIFRvcCBudW1iZXIgb2YgdGhlIHRpbWUgc2lnbmF0dXJlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGVub21pbmF0b3IgLSBCb3R0b20gbnVtYmVyIG9mIHRoZSB0aW1lIHNpZ25hdHVyZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pZGljbG9ja3NwZXJ0aWNrIC0gRGVmYXVsdHMgdG8gMjQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBub3Rlc3Blcm1pZGljbG9jayAtIERlZmF1bHRzIHRvIDguXG5cdCAqIEByZXR1cm4ge1RyYWNrfVxuXHQgKi9cblx0c2V0VGltZVNpZ25hdHVyZShudW1lcmF0b3IsIGRlbm9taW5hdG9yLCBtaWRpY2xvY2tzcGVydGljaywgbm90ZXNwZXJtaWRpY2xvY2spIHtcblx0XHRtaWRpY2xvY2tzcGVydGljayA9IG1pZGljbG9ja3NwZXJ0aWNrIHx8IDI0O1xuXHRcdG5vdGVzcGVybWlkaWNsb2NrID0gbm90ZXNwZXJtaWRpY2xvY2sgfHwgODtcblx0XHRcblx0XHR2YXIgZXZlbnQgPSBuZXcgTWV0YUV2ZW50KHtkYXRhOiBbQ29uc3RhbnRzLk1FVEFfVElNRV9TSUdOQVRVUkVfSURdfSk7XG5cdFx0ZXZlbnQuZGF0YS5wdXNoKDB4MDQpOyAvLyBTaXplXG5cdFx0ZXZlbnQuZGF0YSA9IGV2ZW50LmRhdGEuY29uY2F0KFV0aWxzLm51bWJlclRvQnl0ZXMobnVtZXJhdG9yLCAxKSk7IC8vIE51bWVyYXRvciwgMSBieXRlc1xuXHRcdFxuXHRcdHZhciBfZGVub21pbmF0b3IgPSBNYXRoLmxvZzIoZGVub21pbmF0b3IpO1x0Ly8gRGVub21pbmF0b3IgaXMgZXhwcmVzc2VkIGFzIHBvdyBvZiAyXG5cdFx0ZXZlbnQuZGF0YSA9IGV2ZW50LmRhdGEuY29uY2F0KFV0aWxzLm51bWJlclRvQnl0ZXMoX2Rlbm9taW5hdG9yLCAxKSk7IC8vIERlbm9taW5hdG9yLCAxIGJ5dGVzXG5cdFx0ZXZlbnQuZGF0YSA9IGV2ZW50LmRhdGEuY29uY2F0KFV0aWxzLm51bWJlclRvQnl0ZXMobWlkaWNsb2Nrc3BlcnRpY2ssIDEpKTsgLy8gTUlESSBDbG9ja3MgcGVyIHRpY2ssIDEgYnl0ZXNcblx0XHRldmVudC5kYXRhID0gZXZlbnQuZGF0YS5jb25jYXQoVXRpbHMubnVtYmVyVG9CeXRlcyhub3Rlc3Blcm1pZGljbG9jaywgMSkpOyAvLyBOdW1iZXIgb2YgMS8zMiBub3RlcyBwZXIgTUlESSBjbG9ja3MsIDEgYnl0ZXNcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudChldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBrZXkgc2lnbmF0dXJlLlxuXHQgKiBAcGFyYW0geyp9IHNmIC0gXG5cdCAqIEBwYXJhbSB7Kn0gbWkgLVxuXHQgKiBAcmV0dXJuIHtUcmFja31cblx0ICovXG5cdHNldEtleVNpZ25hdHVyZShzZiwgbWkpIHtcblx0XHR2YXIgZXZlbnQgPSBuZXcgTWV0YUV2ZW50KHtkYXRhOiBbQ29uc3RhbnRzLk1FVEFfS0VZX1NJR05BVFVSRV9JRF19KTtcblx0XHRldmVudC5kYXRhLnB1c2goMHgwMik7IC8vIFNpemVcblxuXHRcdHZhciBtb2RlID0gbWkgfHwgMDtcblx0XHRzZiA9IHNmIHx8IDA7XG5cblx0XHQvL1x0RnVuY3Rpb24gY2FsbGVkIHdpdGggc3RyaW5nIG5vdGF0aW9uXG5cdFx0aWYgKHR5cGVvZiBtaSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHZhciBmaWZ0aHMgPSBbXG5cdFx0XHRcdFsnQ2InLCAnR2InLCAnRGInLCAnQWInLCAnRWInLCAnQmInLCAnRicsICdDJywgJ0cnLCAnRCcsICdBJywgJ0UnLCAnQicsICdGIycsICdDIyddLFxuXHRcdFx0XHRbJ2FiJywgJ2ViJywgJ2JiJywgJ2YnLCAnYycsICdnJywgJ2QnLCAnYScsICdlJywgJ2InLCAnZiMnLCAnYyMnLCAnZyMnLCAnZCMnLCAnYSMnXVxuXHRcdFx0XTtcblx0XHRcdHZhciBfc2ZsZW4gPSBzZi5sZW5ndGg7XG5cdFx0XHR2YXIgbm90ZSA9IHNmIHx8ICdDJztcblxuXHRcdFx0aWYgKHNmWzBdID09PSBzZlswXS50b0xvd2VyQ2FzZSgpKSBtb2RlID0gMVxuXG5cdFx0XHRpZiAoX3NmbGVuID4gMSkge1xuXHRcdFx0XHRzd2l0Y2ggKHNmLmNoYXJBdChfc2ZsZW4gLSAxKSkge1xuXHRcdFx0XHRcdGNhc2UgJ20nOlxuXHRcdFx0XHRcdFx0bW9kZSA9IDE7XG5cdFx0XHRcdFx0XHRub3RlID0gc2YuY2hhckF0KDApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRub3RlID0gbm90ZS5jb25jYXQoc2Yuc3Vic3RyaW5nKDEsIF9zZmxlbiAtIDEpKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJy0nOlxuXHRcdFx0XHRcdFx0bW9kZSA9IDE7XG5cdFx0XHRcdFx0XHRub3RlID0gc2YuY2hhckF0KDApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRub3RlID0gbm90ZS5jb25jYXQoc2Yuc3Vic3RyaW5nKDEsIF9zZmxlbiAtIDEpKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ00nOlxuXHRcdFx0XHRcdFx0bW9kZSA9IDA7XG5cdFx0XHRcdFx0XHRub3RlID0gc2YuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRub3RlID0gbm90ZS5jb25jYXQoc2Yuc3Vic3RyaW5nKDEsIF9zZmxlbiAtIDEpKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJysnOlxuXHRcdFx0XHRcdFx0bW9kZSA9IDA7XG5cdFx0XHRcdFx0XHRub3RlID0gc2YuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRub3RlID0gbm90ZS5jb25jYXQoc2Yuc3Vic3RyaW5nKDEsIF9zZmxlbiAtIDEpKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBmaWZ0aGluZGV4ID0gZmlmdGhzW21vZGVdLmluZGV4T2Yobm90ZSk7XG5cdFx0XHRzZiA9IGZpZnRoaW5kZXggPT09IC0xID8gMCA6IGZpZnRoaW5kZXggLSA3O1xuXHRcdH1cblxuXHRcdGV2ZW50LmRhdGEgPSBldmVudC5kYXRhLmNvbmNhdChVdGlscy5udW1iZXJUb0J5dGVzKHNmLCAxKSk7IC8vIE51bWJlciBvZiBzaGFycCBvciBmbGF0cyAoIDwgMCBmbGF0OyA+IDAgc2hhcnApXG5cdFx0ZXZlbnQuZGF0YSA9IGV2ZW50LmRhdGEuY29uY2F0KFV0aWxzLm51bWJlclRvQnl0ZXMobW9kZSwgMSkpOyAvLyBNb2RlOiAwIG1ham9yLCAxIG1pbm9yXG5cdFx0cmV0dXJuIHRoaXMuYWRkRXZlbnQoZXZlbnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGV4dCB0byBNSURJIGZpbGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGV4dCB0byBhZGQuXG5cdCAqIEByZXR1cm4ge1RyYWNrfVxuXHQgKi9cblx0YWRkVGV4dCh0ZXh0KSB7XG5cdFx0dmFyIGV2ZW50ID0gbmV3IE1ldGFFdmVudCh7ZGF0YTogW0NvbnN0YW50cy5NRVRBX1RFWFRfSURdfSk7XG5cdFx0dmFyIHN0cmluZ0J5dGVzID0gVXRpbHMuc3RyaW5nVG9CeXRlcyh0ZXh0KTtcblx0XHRldmVudC5kYXRhID0gZXZlbnQuZGF0YS5jb25jYXQoVXRpbHMubnVtYmVyVG9WYXJpYWJsZUxlbmd0aChzdHJpbmdCeXRlcy5sZW5ndGgpKTsgLy8gU2l6ZVxuXHRcdGV2ZW50LmRhdGEgPSBldmVudC5kYXRhLmNvbmNhdChzdHJpbmdCeXRlcyk7IC8vIFRleHRcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudChldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBjb3B5cmlnaHQgdG8gTUlESSBmaWxlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRleHQgb2YgY29weXJpZ2h0IGxpbmUuXG5cdCAqIEByZXR1cm4ge1RyYWNrfVxuXHQgKi9cblx0YWRkQ29weXJpZ2h0KHRleHQpIHtcblx0XHR2YXIgZXZlbnQgPSBuZXcgTWV0YUV2ZW50KHtkYXRhOiBbQ29uc3RhbnRzLk1FVEFfQ09QWVJJR0hUX0lEXX0pO1xuXHRcdHZhciBzdHJpbmdCeXRlcyA9IFV0aWxzLnN0cmluZ1RvQnl0ZXModGV4dCk7XG5cdFx0ZXZlbnQuZGF0YSA9IGV2ZW50LmRhdGEuY29uY2F0KFV0aWxzLm51bWJlclRvVmFyaWFibGVMZW5ndGgoc3RyaW5nQnl0ZXMubGVuZ3RoKSk7IC8vIFNpemVcblx0XHRldmVudC5kYXRhID0gZXZlbnQuZGF0YS5jb25jYXQoc3RyaW5nQnl0ZXMpOyAvLyBUZXh0XG5cdFx0cmV0dXJuIHRoaXMuYWRkRXZlbnQoZXZlbnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgU2VxdWVuY2UvVHJhY2sgTmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUZXh0IG9mIHRyYWNrIG5hbWUuXG5cdCAqIEByZXR1cm4ge1RyYWNrfVxuXHQgKi9cblx0YWRkVHJhY2tOYW1lKHRleHQpIHtcblx0XHR2YXIgZXZlbnQgPSBuZXcgTWV0YUV2ZW50KHtkYXRhOiBbQ29uc3RhbnRzLk1FVEFfVFJBQ0tfTkFNRV9JRF19KTtcblx0XHR2YXIgc3RyaW5nQnl0ZXMgPSBVdGlscy5zdHJpbmdUb0J5dGVzKHRleHQpO1xuXHRcdGV2ZW50LmRhdGEgPSBldmVudC5kYXRhLmNvbmNhdChVdGlscy5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKHN0cmluZ0J5dGVzLmxlbmd0aCkpOyAvLyBTaXplXG5cdFx0ZXZlbnQuZGF0YSA9IGV2ZW50LmRhdGEuY29uY2F0KHN0cmluZ0J5dGVzKTsgLy8gVGV4dFxuXHRcdHJldHVybiB0aGlzLmFkZEV2ZW50KGV2ZW50KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGluc3RydW1lbnQgbmFtZSBvZiB0cmFjay5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBOYW1lIG9mIGluc3RydW1lbnQuXG5cdCAqIEByZXR1cm4ge1RyYWNrfVxuXHQgKi9cblx0YWRkSW5zdHJ1bWVudE5hbWUodGV4dCkge1xuXHRcdHZhciBldmVudCA9IG5ldyBNZXRhRXZlbnQoe2RhdGE6IFtDb25zdGFudHMuTUVUQV9JTlNUUlVNRU5UX05BTUVfSURdfSk7XG5cdFx0dmFyIHN0cmluZ0J5dGVzID0gVXRpbHMuc3RyaW5nVG9CeXRlcyh0ZXh0KTtcblx0XHRldmVudC5kYXRhID0gZXZlbnQuZGF0YS5jb25jYXQoVXRpbHMubnVtYmVyVG9WYXJpYWJsZUxlbmd0aChzdHJpbmdCeXRlcy5sZW5ndGgpKTsgLy8gU2l6ZVxuXHRcdGV2ZW50LmRhdGEgPSBldmVudC5kYXRhLmNvbmNhdChzdHJpbmdCeXRlcyk7IC8vIFRleHRcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudChldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBtYXJrZXIgdG8gTUlESSBmaWxlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIE1hcmtlciB0ZXh0LlxuXHQgKiBAcmV0dXJuIHtUcmFja31cblx0ICovXG5cdGFkZE1hcmtlcih0ZXh0KSB7XG5cdFx0dmFyIGV2ZW50ID0gbmV3IE1ldGFFdmVudCh7ZGF0YTogW0NvbnN0YW50cy5NRVRBX01BUktFUl9JRF19KTtcblx0XHR2YXIgc3RyaW5nQnl0ZXMgPSBVdGlscy5zdHJpbmdUb0J5dGVzKHRleHQpO1xuXHRcdGV2ZW50LmRhdGEgPSBldmVudC5kYXRhLmNvbmNhdChVdGlscy5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKHN0cmluZ0J5dGVzLmxlbmd0aCkpOyAvLyBTaXplXG5cdFx0ZXZlbnQuZGF0YSA9IGV2ZW50LmRhdGEuY29uY2F0KHN0cmluZ0J5dGVzKTsgLy8gVGV4dFxuXHRcdHJldHVybiB0aGlzLmFkZEV2ZW50KGV2ZW50KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGN1ZSBwb2ludCB0byBNSURJIGZpbGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGV4dCBvZiBjdWUgcG9pbnQuXG5cdCAqIEByZXR1cm4ge1RyYWNrfVxuXHQgKi9cblx0YWRkQ3VlUG9pbnQodGV4dCkge1xuXHRcdHZhciBldmVudCA9IG5ldyBNZXRhRXZlbnQoe2RhdGE6IFtDb25zdGFudHMuTUVUQV9DVUVfUE9JTlRdfSk7XG5cdFx0dmFyIHN0cmluZ0J5dGVzID0gVXRpbHMuc3RyaW5nVG9CeXRlcyh0ZXh0KTtcblx0XHRldmVudC5kYXRhID0gZXZlbnQuZGF0YS5jb25jYXQoVXRpbHMubnVtYmVyVG9WYXJpYWJsZUxlbmd0aChzdHJpbmdCeXRlcy5sZW5ndGgpKTsgLy8gU2l6ZVxuXHRcdGV2ZW50LmRhdGEgPSBldmVudC5kYXRhLmNvbmNhdChzdHJpbmdCeXRlcyk7IC8vIFRleHRcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudChldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBseXJpYyB0byBNSURJIGZpbGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBseXJpYyAtIEx5cmljIHRleHQgdG8gYWRkLlxuXHQgKiBAcmV0dXJuIHtUcmFja31cblx0ICovXG5cdGFkZEx5cmljKGx5cmljKSB7XG5cdFx0dmFyIGV2ZW50ID0gbmV3IE1ldGFFdmVudCh7ZGF0YTogW0NvbnN0YW50cy5NRVRBX0xZUklDX0lEXX0pO1xuXHRcdHZhciBzdHJpbmdCeXRlcyA9IFV0aWxzLnN0cmluZ1RvQnl0ZXMobHlyaWMpO1xuXHRcdGV2ZW50LmRhdGEgPSBldmVudC5kYXRhLmNvbmNhdChVdGlscy5udW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKHN0cmluZ0J5dGVzLmxlbmd0aCkpOyAvLyBTaXplXG5cdFx0ZXZlbnQuZGF0YSA9IGV2ZW50LmRhdGEuY29uY2F0KHN0cmluZ0J5dGVzKTsgLy8gTHlyaWNcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudChldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hhbm5lbCBtb2RlIG1lc3NhZ2VzXG5cdCAqIEByZXR1cm4ge1RyYWNrfVxuXHQgKi9cblx0cG9seU1vZGVPbigpIHtcblx0XHR2YXIgZXZlbnQgPSBuZXcgTm90ZU9uRXZlbnQoe2RhdGE6IFsweDAwLCAweEIwLCAweDdFLCAweDAwXX0pO1xuXHRcdHJldHVybiB0aGlzLmFkZEV2ZW50KGV2ZW50KTtcblx0fVxuXG59XG5cbmV4cG9ydCB7VHJhY2t9O1xuaW1wb3J0IHt0b01pZGl9IGZyb20gJ3RvbmFsLW1pZGknO1xuXG4vKipcbiAqIFN0YXRpYyB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIHRocm91Z2hvdXQgdGhlIGxpYnJhcnkuXG4gKi9cbmNsYXNzIFV0aWxzIHtcblxuXHQvKipcblx0ICogR2V0cyBNaWRpV3JpdGVySlMgdmVyc2lvbiBudW1iZXIuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdHN0YXRpYyB2ZXJzaW9uKCkge1xuXHRcdHJldHVybiBDb25zdGFudHMuVkVSU0lPTjtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGJ5dGVzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcblx0ICogQHJldHVybiB7YXJyYXl9XG5cdCAqL1xuXHRzdGF0aWMgc3RyaW5nVG9CeXRlcyhzdHJpbmcpIHtcblx0XHRyZXR1cm4gc3RyaW5nLnNwbGl0KCcnKS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoKSlcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYXJndW1lbnQgaXMgYSB2YWxpZCBudW1iZXIuXG5cdCAqIEBwYXJhbSB7Kn0gbiAtIFZhbHVlIHRvIGNoZWNrXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRzdGF0aWMgaXNOdW1lcmljKG4pIHtcblx0XHRyZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pXG5cdH1cblxuXHQvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb3JyZWN0IE1JREkgbnVtYmVyIGZvciB0aGUgc3BlY2lmaWVkIHBpdGNoLlxuICAgICAqIFVzZXMgVG9uYWwgTWlkaSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5pZ2IvdG9uYWwvdHJlZS9tYXN0ZXIvcGFja2FnZXMvbWlkaVxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpfSBwaXRjaCAtICdDIzQnIG9yIG1pZGkgbm90ZSBjb2RlXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgICBzdGF0aWMgZ2V0UGl0Y2gocGl0Y2gpIHtcbiAgICAgXHRyZXR1cm4gdG9NaWRpKHBpdGNoKTtcbiAgICAgfVxuXG5cdC8qKlxuXHQgKiBUcmFuc2xhdGVzIG51bWJlciBvZiB0aWNrcyB0byBNSURJIHRpbWVzdGFtcCBmb3JtYXQsIHJldHVybmluZyBhbiBhcnJheSBvZlxuXHQgKiBoZXggc3RyaW5ncyB3aXRoIHRoZSB0aW1lIHZhbHVlcy4gTWlkaSBoYXMgYSB2ZXJ5IHBhcnRpY3VsYXIgdGltZSB0byBleHByZXNzIHRpbWUsXG5cdCAqIHRha2UgYSBnb29kIGxvb2sgYXQgdGhlIHNwZWMgYmVmb3JlIGV2ZXIgdG91Y2hpbmcgdGhpcyBmdW5jdGlvbi5cblx0ICogVGhhbmtzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zZXJnaS9qc21pZGlcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpY2tzIC0gTnVtYmVyIG9mIHRpY2tzIHRvIGJlIHRyYW5zbGF0ZWRcblx0ICogQHJldHVybiB7YXJyYXl9IC0gQnl0ZXMgdGhhdCBmb3JtIHRoZSBNSURJIHRpbWUgdmFsdWVcblx0ICovXG5cdHN0YXRpYyBudW1iZXJUb1ZhcmlhYmxlTGVuZ3RoKHRpY2tzKSB7XG5cdCAgICB2YXIgYnVmZmVyID0gdGlja3MgJiAweDdGO1xuXG5cdCAgICB3aGlsZSAodGlja3MgPSB0aWNrcyA+PiA3KSB7XG5cdCAgICAgICAgYnVmZmVyIDw8PSA4O1xuXHQgICAgICAgIGJ1ZmZlciB8PSAoKHRpY2tzICYgMHg3RikgfCAweDgwKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGJMaXN0ID0gW107XG5cdCAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgIGJMaXN0LnB1c2goYnVmZmVyICYgMHhmZik7XG5cblx0ICAgICAgICBpZiAoYnVmZmVyICYgMHg4MCkgYnVmZmVyID4+PSA4XG5cdCAgICAgICAgZWxzZSB7IGJyZWFrOyB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBiTGlzdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb3VudHMgbnVtYmVyIG9mIGJ5dGVzIGluIHN0cmluZ1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gc1xuXHQgKiBAcmV0dXJuIHthcnJheX1cblx0ICovXG5cdHN0YXRpYyBzdHJpbmdCeXRlQ291bnQocykge1xuXHRcdHJldHVybiBlbmNvZGVVUkkocykuc3BsaXQoLyUuLnwuLykubGVuZ3RoIC0gMVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBhbiBpbnQgZnJvbSBhbiBhcnJheSBvZiBieXRlcy5cblx0ICogQHBhcmFtIHthcnJheX0gYnl0ZXNcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0c3RhdGljIG51bWJlckZyb21CeXRlcyhieXRlcykge1xuXHRcdHZhciBoZXggPSAnJztcblx0XHR2YXIgc3RyaW5nUmVzdWx0O1xuXG5cdFx0Ynl0ZXMuZm9yRWFjaChmdW5jdGlvbihieXRlKSB7XG5cdFx0XHRzdHJpbmdSZXN1bHQgPSBieXRlLnRvU3RyaW5nKDE2KTtcblxuXHRcdFx0Ly8gZW5zdXJlIHN0cmluZyBpcyAyIGNoYXJzXG5cdFx0XHRpZiAoc3RyaW5nUmVzdWx0Lmxlbmd0aCA9PSAxKSBzdHJpbmdSZXN1bHQgPSBcIjBcIiArIHN0cmluZ1Jlc3VsdFxuXG5cdFx0XHRoZXggKz0gc3RyaW5nUmVzdWx0O1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHBhcnNlSW50KGhleCwgMTYpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRha2VzIGEgbnVtYmVyIGFuZCBzcGxpdHMgaXQgdXAgaW50byBhbiBhcnJheSBvZiBieXRlcy4gIENhbiBiZSBwYWRkZWQgYnkgcGFzc2luZyBhIG51bWJlciB0byBieXRlc05lZWRlZFxuXHQgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc05lZWRlZFxuXHQgKiBAcmV0dXJuIHthcnJheX0gLSBBcnJheSBvZiBieXRlc1xuXHQgKi9cblx0c3RhdGljIG51bWJlclRvQnl0ZXMobnVtYmVyLCBieXRlc05lZWRlZCkge1xuXHRcdGJ5dGVzTmVlZGVkID0gYnl0ZXNOZWVkZWQgfHwgMTtcblxuXHRcdHZhciBoZXhTdHJpbmcgPSBudW1iZXIudG9TdHJpbmcoMTYpO1xuXG5cdFx0aWYgKGhleFN0cmluZy5sZW5ndGggJiAxKSB7IC8vIE1ha2Ugc3VyZSBoZXggc3RyaW5nIGlzIGV2ZW4gbnVtYmVyIG9mIGNoYXJzXG5cdFx0XHRoZXhTdHJpbmcgPSAnMCcgKyBoZXhTdHJpbmc7XG5cdFx0fVxuXG5cdFx0Ly8gU3BsaXQgaGV4IHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHR3byBjaGFyIGVsZW1lbnRzXG5cdFx0dmFyIGhleEFycmF5ID0gaGV4U3RyaW5nLm1hdGNoKC8uezJ9L2cpO1xuXG5cdFx0Ly8gTm93IHBhcnNlIHRoZW0gb3V0IGFzIGludGVnZXJzXG5cdFx0aGV4QXJyYXkgPSBoZXhBcnJheS5tYXAoaXRlbSA9PiBwYXJzZUludChpdGVtLCAxNikpXG5cblx0XHQvLyBQcmVwZW5kIGVtcHR5IGJ5dGVzIGlmIHdlIGRvbid0IGhhdmUgZW5vdWdoXG5cdFx0aWYgKGhleEFycmF5Lmxlbmd0aCA8IGJ5dGVzTmVlZGVkKSB7XG5cdFx0XHR3aGlsZSAoYnl0ZXNOZWVkZWQgLSBoZXhBcnJheS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGhleEFycmF5LnVuc2hpZnQoMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhleEFycmF5O1xuXHR9XG5cblx0LyoqXHRcblx0ICogQ29udmVydHMgdmFsdWUgdG8gYXJyYXkgaWYgbmVlZGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICogQHJldHVybiB7YXJyYXl9XG5cdCAqL1xuXHRzdGF0aWMgdG9BcnJheSh2YWx1ZSkge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuXHRcdHJldHVybiBbdmFsdWVdO1xuXHR9XG59XG5cbmV4cG9ydCB7VXRpbHN9O1xuY2xhc3MgVmV4RmxvdyB7XG5cdFxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHQvLyBjb2RlLi4uXG5cdH1cblxuXHQvKipcblx0ICogU3VwcG9ydCBmb3IgY29udmVydGluZyBWZXhGbG93IHZvaWNlIGludG8gTWlkaVdyaXRlckpTIHRyYWNrXG5cdCAqIEByZXR1cm4gTWlkaVdyaXRpZXIuVHJhY2sgb2JqZWN0XG5cdCAqL1xuXHR0cmFja0Zyb21Wb2ljZSh2b2ljZSkge1xuXHRcdHZhciB0cmFjayA9IG5ldyBUcmFjaygpO1xuXHRcdHZhciB3YWl0O1xuXHRcdHZhciBwaXRjaGVzID0gW107XG5cblx0XHR2b2ljZS50aWNrYWJsZXMuZm9yRWFjaChmdW5jdGlvbih0aWNrYWJsZSkge1xuXHRcdFx0cGl0Y2hlcyA9IFtdO1xuXG5cdFx0XHRpZiAodGlja2FibGUubm90ZVR5cGUgPT09ICduJykge1xuXHRcdFx0XHR0aWNrYWJsZS5rZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdFx0Ly8gYnVpbGQgYXJyYXkgb2YgcGl0Y2hlc1xuXHRcdFx0XHRcdHBpdGNoZXMucHVzaCh0aGlzLmNvbnZlcnRQaXRjaChrZXkpKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdH0gZWxzZSBpZiAodGlja2FibGUubm90ZVR5cGUgPT09ICdyJykge1xuXHRcdFx0XHQvLyBtb3ZlIG9uIHRvIHRoZSBuZXh0IHRpY2thYmxlIGFuZCB1c2UgdGhpcyByZXN0IGFzIGEgYHdhaXRgIHByb3BlcnR5IGZvciB0aGUgbmV4dCBldmVudFxuXHRcdFx0XHR3YWl0ID0gdGhpcy5jb252ZXJ0RHVyYXRpb24odGlja2FibGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRyYWNrLmFkZEV2ZW50KG5ldyBOb3RlRXZlbnQoe3BpdGNoOiBwaXRjaGVzLCBkdXJhdGlvbjogdGhpcy5jb252ZXJ0RHVyYXRpb24odGlja2FibGUpLCB3YWl0OiB3YWl0fSkpO1xuXHRcdFx0XG5cdFx0XHQvLyByZXNldCB3YWl0XG5cdFx0XHR3YWl0ID0gMDtcblx0XHR9KTtcblxuXHRcdHJldHVybiB0cmFjaztcblx0fVxuXG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIFZleEZsb3cgcGl0Y2ggc3ludGF4IHRvIE1pZGlXcml0ZXJKUyBzeW50YXhcblx0ICogQHBhcmFtIHBpdGNoIHN0cmluZ1xuXHQgKi9cblx0Y29udmVydFBpdGNoKHBpdGNoKSB7XG5cdFx0cmV0dXJuIHBpdGNoLnJlcGxhY2UoJy8nLCAnJyk7XG5cdH0gXG5cblxuXHQvKipcblx0ICogQ29udmVydHMgVmV4RmxvdyBkdXJhdGlvbiBzeW50YXggdG8gTWlkaVdyaXRlckpTIHN5bnRheFxuXHQgKiBAcGFyYW0gbm90ZSBzdHJ1Y3QgZnJvbSBWZXhGbG93XG5cdCAqL1xuXHRjb252ZXJ0RHVyYXRpb24obm90ZSkge1xuXHRcdHN3aXRjaCAobm90ZS5kdXJhdGlvbikge1xuXHRcdFx0Y2FzZSAndyc6XG5cdFx0XHRcdHJldHVybiAnMSc7XG5cdFx0XHRjYXNlICdoJzpcblx0XHRcdFx0cmV0dXJuIG5vdGUuaXNEb3R0ZWQoKSA/ICdkMicgOiAnMic7XG5cdFx0XHRjYXNlICdxJzpcblx0XHRcdFx0cmV0dXJuIG5vdGUuaXNEb3R0ZWQoKSA/ICdkNCcgOiAnNCc7XG5cdFx0XHRjYXNlICc4Jzpcblx0XHRcdFx0cmV0dXJuIG5vdGUuaXNEb3R0ZWQoKSA/ICdkOCcgOiAnOCc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vdGUuZHVyYXRpb247XG5cdH07XG59XG5cbmV4cG9ydCB7VmV4Rmxvd307XG4vKipcbiAqIE9iamVjdCB0aGF0IHB1dHMgdG9nZXRoZXIgdHJhY2tzIGFuZCBwcm92aWRlcyBtZXRob2RzIGZvciBmaWxlIG91dHB1dC5cbiAqIEBwYXJhbSB7YXJyYXl9IHRyYWNrcyAtIEFuIGFycmF5IG9mIHtUcmFja30gb2JqZWN0cy5cbiAqIEByZXR1cm4ge1dyaXRlcn1cbiAqL1xuY2xhc3MgV3JpdGVyIHtcblx0Y29uc3RydWN0b3IodHJhY2tzKSB7XG5cdFx0dGhpcy5kYXRhID0gW107XG5cblx0XHR2YXIgdHJhY2tUeXBlID0gdHJhY2tzLmxlbmd0aCA+IDEgPyBDb25zdGFudHMuSEVBREVSX0NIVU5LX0ZPUk1BVDEgOiBDb25zdGFudHMuSEVBREVSX0NIVU5LX0ZPUk1BVDA7XG5cdFx0dmFyIG51bWJlck9mVHJhY2tzID0gVXRpbHMubnVtYmVyVG9CeXRlcyh0cmFja3MubGVuZ3RoLCAyKTsgLy8gdHdvIGJ5dGVzIGxvbmdcblxuXHRcdC8vIEhlYWRlciBjaHVua1xuXHRcdHRoaXMuZGF0YS5wdXNoKG5ldyBDaHVuayh7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogQ29uc3RhbnRzLkhFQURFUl9DSFVOS19UWVBFLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGE6IHRyYWNrVHlwZS5jb25jYXQobnVtYmVyT2ZUcmFja3MsIENvbnN0YW50cy5IRUFERVJfQ0hVTktfRElWSVNJT04pfSkpO1xuXG5cdFx0Ly8gVHJhY2sgY2h1bmtzXG5cdFx0dHJhY2tzLmZvckVhY2goZnVuY3Rpb24odHJhY2ssIGkpIHtcblx0XHRcdHRyYWNrLmFkZEV2ZW50KG5ldyBNZXRhRXZlbnQoe2RhdGE6IENvbnN0YW50cy5NRVRBX0VORF9PRl9UUkFDS19JRH0pKTtcblx0XHRcdHRoaXMuZGF0YS5wdXNoKHRyYWNrKTtcblx0XHR9LCB0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCdWlsZHMgdGhlIGZpbGUgaW50byBhIFVpbnQ4QXJyYXlcblx0ICogQHJldHVybiB7VWludDhBcnJheX1cblx0ICovXG5cdGJ1aWxkRmlsZSgpIHtcblx0XHR2YXIgYnVpbGQgPSBbXTtcblxuXHRcdC8vIERhdGEgY29uc2lzdHMgb2YgY2h1bmtzIHdoaWNoIGNvbnNpc3RzIG9mIGRhdGFcblx0XHR0aGlzLmRhdGEuZm9yRWFjaCgoZCkgPT4gYnVpbGQgPSBidWlsZC5jb25jYXQoZC50eXBlLCBkLnNpemUsIGQuZGF0YSkpO1xuXG5cdFx0cmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1aWxkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGZpbGUgYnVmZmVyIHRvIGEgYmFzZTY0IHN0cmluZy4gIERpZmZlcmVudCBtZXRob2RzIGRlcGVuZGluZyBvbiBpZiBicm93c2VyIG9yIG5vZGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGJhc2U2NCgpIHtcblx0XHRpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHJldHVybiBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdGhpcy5idWlsZEZpbGUoKSkpO1xuXHRcdHJldHVybiBuZXcgQnVmZmVyKHRoaXMuYnVpbGRGaWxlKCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkYXRhIFVSSS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZGF0YVVyaSgpIHtcbiAgICBcdHJldHVybiAnZGF0YTphdWRpby9taWRpO2Jhc2U2NCwnICsgdGhpcy5iYXNlNjQoKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIE91dHB1dCB0byBzdGRvdXRcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgICBzdGRvdXQoKSB7XG4gICAgXHRyZXR1cm4gcHJvY2Vzcy5zdGRvdXQud3JpdGUobmV3IEJ1ZmZlcih0aGlzLmJ1aWxkRmlsZSgpKSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBTYXZlIHRvIE1JREkgZmlsZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWVcblx0ICovXG5cdHNhdmVNSURJKGZpbGVuYW1lKSB7XG5cdFx0dmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5idWlsZEZpbGUoKSk7XG5cdFx0ZnMud3JpdGVGaWxlKGZpbGVuYW1lICsgJy5taWQnLCBidWZmZXIsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdGlmKGVycikgcmV0dXJuIGNvbnNvbGUubG9nKGVycik7XG5cdFx0fSk7XG5cdH1cbn1cblxuZXhwb3J0IHtXcml0ZXJ9O1xuIl19
